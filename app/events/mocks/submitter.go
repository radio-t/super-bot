// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"
)

// Submitter is a mock implementation of events.submitter.
//
//	func TestSomethingThatUsessubmitter(t *testing.T) {
//
//		// make and configure a mocked events.submitter
//		mockedsubmitter := &Submitter{
//			SubmitFunc: func(ctx context.Context, text string, pin bool) error {
//				panic("mock out the Submit method")
//			},
//			SubmitHTMLFunc: func(ctx context.Context, text string, pin bool) error {
//				panic("mock out the SubmitHTML method")
//			},
//		}
//
//		// use mockedsubmitter in code that requires events.submitter
//		// and then make assertions.
//
//	}
type Submitter struct {
	// SubmitFunc mocks the Submit method.
	SubmitFunc func(ctx context.Context, text string, pin bool) error

	// SubmitHTMLFunc mocks the SubmitHTML method.
	SubmitHTMLFunc func(ctx context.Context, text string, pin bool) error

	// calls tracks calls to the methods.
	calls struct {
		// Submit holds details about calls to the Submit method.
		Submit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Text is the text argument value.
			Text string
			// Pin is the pin argument value.
			Pin bool
		}
		// SubmitHTML holds details about calls to the SubmitHTML method.
		SubmitHTML []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Text is the text argument value.
			Text string
			// Pin is the pin argument value.
			Pin bool
		}
	}
	lockSubmit     sync.RWMutex
	lockSubmitHTML sync.RWMutex
}

// Submit calls SubmitFunc.
func (mock *Submitter) Submit(ctx context.Context, text string, pin bool) error {
	if mock.SubmitFunc == nil {
		panic("Submitter.SubmitFunc: method is nil but submitter.Submit was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Text string
		Pin  bool
	}{
		Ctx:  ctx,
		Text: text,
		Pin:  pin,
	}
	mock.lockSubmit.Lock()
	mock.calls.Submit = append(mock.calls.Submit, callInfo)
	mock.lockSubmit.Unlock()
	return mock.SubmitFunc(ctx, text, pin)
}

// SubmitCalls gets all the calls that were made to Submit.
// Check the length with:
//
//	len(mockedsubmitter.SubmitCalls())
func (mock *Submitter) SubmitCalls() []struct {
	Ctx  context.Context
	Text string
	Pin  bool
} {
	var calls []struct {
		Ctx  context.Context
		Text string
		Pin  bool
	}
	mock.lockSubmit.RLock()
	calls = mock.calls.Submit
	mock.lockSubmit.RUnlock()
	return calls
}

// SubmitHTML calls SubmitHTMLFunc.
func (mock *Submitter) SubmitHTML(ctx context.Context, text string, pin bool) error {
	if mock.SubmitHTMLFunc == nil {
		panic("Submitter.SubmitHTMLFunc: method is nil but submitter.SubmitHTML was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Text string
		Pin  bool
	}{
		Ctx:  ctx,
		Text: text,
		Pin:  pin,
	}
	mock.lockSubmitHTML.Lock()
	mock.calls.SubmitHTML = append(mock.calls.SubmitHTML, callInfo)
	mock.lockSubmitHTML.Unlock()
	return mock.SubmitHTMLFunc(ctx, text, pin)
}

// SubmitHTMLCalls gets all the calls that were made to SubmitHTML.
// Check the length with:
//
//	len(mockedsubmitter.SubmitHTMLCalls())
func (mock *Submitter) SubmitHTMLCalls() []struct {
	Ctx  context.Context
	Text string
	Pin  bool
} {
	var calls []struct {
		Ctx  context.Context
		Text string
		Pin  bool
	}
	mock.lockSubmitHTML.RLock()
	calls = mock.calls.SubmitHTML
	mock.lockSubmitHTML.RUnlock()
	return calls
}
